---
id: trait入门
title: trait入门
sidebar_position: 12
date: 2022-10-16
tags: [rust, struct, trait, impl]
---

# trait入门

>   定义共享行为的接口设计。和`java`以及`php`里的抽象类或者接口类似。



目录层级

```
➜  mypro git:(dev_trait) ✗ tree -L 3
.
├── Cargo.lock
├── Cargo.toml
├── README.md
├── src
│   ├── api
│   │   ├── mod.rs
│   │   └── prods.rs
│   ├── lib
│   │   ├── config.rs
│   │   └── mod.rs
│   ├── main.rs
│   └── models
│       ├── book_model.rs
│       ├── mod.rs
│       └── user_model.rs
```



## 定义实体类

定义一个`Book`的实体

```rust title="models/book_model.rs"
// 图书实体

#[derive(Debug)]
pub struct Book {
    pub id: i32,
    pub price: f32,
}

// 所谓的实例化函数
pub fn new_book(id: i32, price: f32) -> Book {
    // 表达式
    Book {
        id: id,
        price: price,
    }
}

```

同样的，必须在同级目录里的`mod.rs`里进行暴露，让外部可以使用

```rust title="models/mod.rs"
pub mod book_model;
pub mod user_model; // 这个是上一个demo里的内容
```



这次我们和上面写在实体里的方法不一样，我们另外新建一个`src/api`目录，里面包含一个`mod.rs`和一个商品的抽象接口或者抽象类

```rust title="api/prods.rs"
// 写成接口或抽象类

// crate 比 mod 级别更高
use crate::models::book_model::Book;

pub trait Prods {
    fn get_price(&self) -> f32;
}

// 使用 trait 对某一个 struct 定义方法
impl Prods for Book {
    fn get_price(&self) -> f32 {
        // 让价格加10元
        &self.price + 10.0
    }
}

```

:::warning 注意

这里我们需要使用外部的`Book`实体，就不能向`main.rs`里直接`user`目录层级下的即可，这里需要使用`crate`获取上一层，然后再去获取对应的实体。

:::

这里的`Prods`就和`java`里的`interface`一样，只定义一个方法名，而且是以分号结尾，然后另外写方法实现。

`main.rs`调用，这里我们在`mod.rs`写成这样，方便我们理解

```rust title="api/mod.rs"
pub mod prods;
pub use prods::*;
```

直接在`mod.rs`里可以调用`prods`里的所有`pub`的内容；然后在`main.rs`里就不用`use`很多层。

```rust title="main.rs"
mod api;
mod models;
use api::Prods;
use models::book_model::*;

fn main() {
    let book = new_book(101, 25.0);
    println!("{:?}", book.get_price());
}

```

`use api::Prods;`如果我们没有写`pub use prods::*;`，那么这里就得写成`use api::prods::Prods;`。

调用结果：

```bash
cargo build && cargo run

35.0
```

